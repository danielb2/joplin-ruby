#!/usr/bin/env ruby

$:.unshift File.expand_path('../lib', __dir__)

require 'joplin'
require 'thor'

DIVIDER = %(

<svg height="50" width="460">
  <style> .line { stroke-width: 1px; fill: black; stroke: black; } </style>
  <g id="triangle"><path d="M0 30 L200 30  Q 220 25 200 35 Z" class="line" /></g>
  <use href="#triangle" transform="scale(-1 1) translate(-450 0)"/>
  <circle cx="225" cy="32" r="7" class="line"/>
</svg>

)

class MyCLI < Thor
  class_option :token, type: :string # , required: true
  class_option :help, type: :boolean
  class_option :version, type: :boolean
  map ['-v', '--version'] => :version
  map ['-h', '--help'] => :help
  option :token
  option :'dry-run', desc: 'dry-run', aliases: '-n'
  desc :clean, 'clean unused resources'
  def clean
    Joplin.token = Joplinl.get_token || options[:token]
    puts 'Please wait, this can take while.'
    Joplin::Resource.orphaned.map do |r|
      r.delete unless options['dry-run']
      would = 'would have ' if options['dry-run']
      puts "#{would}deleted #{r.id}"
    end
  end

  method_options force: :boolean
  desc 'version', 'get version of program'
  def version
    puts Joplin::VERSION
  end

  desc 'write', 'write a note'
  long_desc 'This will write a note in the format of "note title/note title.md and put all resources under the folder'
  def write(id)
    note = Joplin::Note.new(id:)
    note.write
  end

  desc :nb2n, 'concate all notes in a notebook to one note. Possible PDF export'
  long_desc 'The idea is to make a big note from all the notes in a notebook. PDF export or whatever export can happen from that. The notes are concatenated with a separator.'
  option :token
  option :type, type: :string
  def nb2n(query)
    Joplin.token = options[:token] || Joplin::Token.get
    results = Joplin.search(query, { type: 'folder' })
    nb = results[0]
    abort "notebook #{query} not found" unless nb and nb['title'] == query

    notebook = Joplin::Notebook.new nb['id']
    notes = notebook.notes
    new_note = Joplin::Note.new
    new_note.title = query
    new_note.body = notes.map { |n| "\# #{n.title}\n\n#{n.body}" }.join
    new_note.save!
    puts "Saved: #{new_note.title} with id: #{new_note.id}"
  end

  desc :build, 'build a note from a note containing references'

  long_desc %(Takes a note and looks up all the referenced notes and makes a new
  note from those in the same folder. The notes are concatenated with a separator.\n\nIf you have a
  line with 'title: a title' then it will be used for the title of the built
  note.)

  def build(id)
    token
    note = Joplin::Note.new(id:)
    notes = []
    title = nil
    note.body.each_line do |line|
      title = ::Regexp.last_match(1) if line =~ /title: (.*)$/
      line =~ %r{\(:/(\w+)\)}
      begin
        if ::Regexp.last_match(1)
          notes.push Joplin::Note.new id: ::Regexp.last_match(1) if ::Regexp.last_match(1)
          print '.'
        end
      rescue Joplin::Note::NotFound
        puts "Couldn't find note with id #{id} so we skip it"
      end
    end
    new_note = Joplin::Note.new parent_id: note.parent_id
    new_note.title = title || "built: #{note.title}"
    new_note.body = notes.map { |n| "\# #{n.title}\n\n#{n.body}" }.join
    new_note.save!
    puts "\nSaved: `#{new_note.title}` with id: #{new_note.id}, parent_id: #{new_note.parent_id}"
  end

  private

  def token
    Joplin.token = Joplin.get_token || options[:token]
    return if Joplin.token

    raise "Couldn't find token in local database and it wasn't passed as an option. You better check yourself!"
  end
end

MyCLI.start(ARGV)
